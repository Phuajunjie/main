<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>PokkaKiyo - Project Portfolio</title>
<link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>PokkaKiyo - Project Portfolio</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="project-contact-em"><a class="link" href="#project-contact-em">Project: Contact&#8217;em</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Contact’em is a desktop address book application, and the user interacts with it through typing commands into the application.</p>
</div>
<div class="paragraph">
<p><strong>Code contributed</strong>: [<a href="https://github.com">Functional code</a>] [<a href="https://github.com">Test code</a>]</p>
</div>
<div class="sect2">
<h3 id="enhancement-added-find-contacts-by-tags"><a class="link" href="#enhancement-added-find-contacts-by-tags">Enhancement Added: Find Contacts by Tags</a></h3>
<div class="sect3">
<h4 id="external-behavior"><a class="link" href="#external-behavior">External behavior</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locating-persons-by-tag-name-code-findtags-code"><a class="link" href="#locating-persons-by-tag-name-code-findtags-code">Locating persons by tag name: <code>findtags</code></a></h3>
<div class="paragraph">
<p><code>SINCE V1.2</code></p>
</div>
<div class="paragraph">
<p>Finds persons who have tags matching any of the given keywords.<br></p>
</div>
<div class="sect3">
<h4 id="the-command"><a class="link" href="#the-command">The Command</a></h4>
<div class="paragraph">
<p>Format: <code>findtags KEYWORD [MORE_KEYWORDS]</code><br></p>
</div>
</div>
<div class="sect3">
<h4 id="examples"><a class="link" href="#examples">Examples</a></h4>
<div class="ulist">
<ul>
<li>
<p><code>findtags friends</code><br>
Returns any contact tagged <code>friends</code>.</p>
</li>
<li>
<p><code>findtags friends colleagues schoolmates</code><br>
Returns any person having any of the tags <code>friends</code>, <code>colleagues</code>, and/or <code>schoolmates</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="demonstration"><a class="link" href="#demonstration">Demonstration</a></h4>
<div class="imageblock">
<div class="content">
<img src="../images/findtags-before.png" alt="findtags before" width="200">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.6.3a : Before entering command</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/findtags-enter-command.png" alt="findtags enter command" width="200">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.6.3b : Entering command to find all contacted tagged as friends</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/findtags-after.png" alt="findtags after" width="200">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.6.3c : Application displays all contacts tagged as friends</em></p>
</div>
<div class="paragraph">
<p>The figures above demonstrate an example of how this command is used.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can substitute the command <code>findtags</code> with <code>findtag</code> or <code>ft</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The search is <strong>not</strong> case-sensitive.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The order of the keywords does not matter.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only full words will be matched. For example, <code>fri</code> will <strong>not</strong> match <code>friends</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Contact with at least one of the specified tag keywords will be displayed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="note-on-singular-and-plural-tenses"><a class="link" href="#note-on-singular-and-plural-tenses">Note on singular and plural tenses</a></h4>
<div class="paragraph">
<p>The search will attempt to be more lenient with singular and plural tenses.</p>
</div>
<div class="paragraph">
<p>For example:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>friend</code> will return contacts with either tag <code>friend</code> or <code>friends</code>.<br></p>
</li>
<li>
<p><code>colleagues</code> will return contacts with either tag <code>colleague</code> or <code>colleagues</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, this may not always be correct for words where plural and singular differs not only by a single letter 's'.
Searching by tag <code>family</code> will attempt to find contacts with tags <code>family</code> and <code>familyS</code> instead of <code>families</code>.
Therefore, the onus is still on the user to specify the spelling of the tags.</p>
</div>
</div>
<div class="sect3">
<h4 id="specifying-exclusions"><a class="link" href="#specifying-exclusions">Specifying Exclusions</a></h4>
<div class="paragraph">
<p><code>since v1.4</code></p>
</div>
<div class="paragraph">
<p>You can now specify tags to be excluded in this command, by simply adding a dash ('-') before keywords specified for exclusion.
This feature will help you better manage your contacts.</p>
</div>
<div class="sect4">
<h5 id="usage-examples-of-exclusions"><a class="link" href="#usage-examples-of-exclusions">Usage examples of exclusions</a></h5>
<div class="paragraph">
<p>Specifying both tags to include and tags to exclude<br>
Example 1:
<code>findtags</code> friends <mark>-colleagues</mark><br>
In this case, the application will show only those who are tagged as friends, but are <mark>NOT</mark> tagged as colleagues.</p>
</div>
<div class="paragraph">
<p>Specifying only tags to exclude<br>
Example 2:
<code>findtags</code> <mark>-colleagues</mark><br>
In this case, the application will show <strong>all</strong> contacts who are <mark>NOT</mark> tagged colleagues, regardless of other tags.</p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="justification"><a class="link" href="#justification">Justification</a></h4>
<div class="paragraph">
<p>The main theme of Contact&#8217;em is to be able to easily find/filter the contacts in the application.
This feature allows users to easily search for contacts in big numbers by locating them according to their tags.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation"><a class="link" href="#implementation">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="finding-contacts-by-tags"><a class="link" href="#finding-contacts-by-tags">Finding contacts by tags</a></h3>
<div class="paragraph">
<p>The application allows users to find contacts based on their tags. The command word is <code>findtags</code>, and the alternatives are <code>findtag</code> and <code>ft</code>. The following subsections explain how the program is supposed to function given this command, and how it is implemented.</p>
</div>
<div class="sect3">
<h4 id="user-inputs-and-expected-actions-results"><a class="link" href="#user-inputs-and-expected-actions-results">User Inputs and Expected Actions/Results</a></h4>
<div class="paragraph">
<p>In general, there are three ways users will use this command. Some pseudo-code is provided for each of these 3 scenarios to aid understanding.</p>
</div>
<div class="paragraph">
<p><strong>Scenario 1</strong></p>
</div>
<div class="paragraph">
<p>In the first scenario, also the most basic, the user only specifies tags to <strong>include</strong>. For this, the program should simply return all contacts that have at least one of the tags.</p>
</div>
<div class="paragraph">
<p><strong>Example Command 1:</strong> findtags friends<br>
Expected result: returns contacts that are tagged “friends”.</p>
</div>
<div class="paragraph">
<p><strong>Pseudo-code snippet</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">for</span> each tag : contact.getTagList {
<span class="keyword">if</span> (keywordsToInclude.hasAnyMatchingWordsWith(tag.value)) {
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}
<span class="keyword">return</span> <span class="predefined-constant">false</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Scenario 2</strong></p>
</div>
<div class="paragraph">
<p>In the second scenario, the user only specifies tags to <strong>exclude</strong>. To specify a tag to exclude, user includes a hyphen -  before the keyword to be excluded. In this case, the program should return all contacts that do not have any of these tags to be excluded.</p>
</div>
<div class="paragraph">
<p>Note that this includes contacts with no tags.</p>
</div>
<div class="paragraph">
<p><strong>Example Command 2:</strong> findtags -colleagues<br>
Expected result: returns all contacts not tagged “colleagues”.</p>
</div>
<div class="paragraph">
<p><strong>Pseudo-code snippet</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">for</span> each tag : contact.getTagList {
<span class="keyword">if</span> (keywordsToExclude.hasAnyMatchingWordsWith(tag.value)) {
<span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}
<span class="keyword">return</span> <span class="predefined-constant">true</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Scenario 3</strong></p>
</div>
<div class="paragraph">
<p>In the third scenario, the user specifies <strong>both tags to include and exclude</strong>. The program will return all contacts that have:<br>
1) ANY of the tags to include.<br>
2) NONE of the tags to exclude.</p>
</div>
<div class="paragraph">
<p><strong>Example Command 3:</strong> findtags friends -colleagues<br>
Expected result: returns all contacts tagged “friends” but not tagged “colleagues”.</p>
</div>
<div class="paragraph">
<p><strong>Pseudo-code snippet:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> personHasAtLeastOneMatchingTag = <span class="predefined-constant">false</span>;

<span class="keyword">for</span> each tag : contact.getTagList {
     <span class="keyword">if</span> keywordsToExclude.hasAnyMatchingWordsWith(tag.value)
                <span class="keyword">return</span> <span class="predefined-constant">false</span>;
     If keywordsToInclude.hasAnyMatchingWordsWith(person.getTagList()
                 personHasAtLeastOneMatchingTag = <span class="predefined-constant">true</span>;
}

<span class="keyword">if</span> (personHasAtLeastOneMatchingTag)
      <span class="keyword">return</span> <span class="predefined-constant">true</span>;
<span class="keyword">else</span>
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There must be at least one parameter specified, but the order of parameters entered does not matter.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="brief-overview-of-command-procedure"><a class="link" href="#brief-overview-of-command-procedure">Brief Overview of Command Procedure</a></h4>
<div class="paragraph">
<p>The activity diagram below helps illustrate the process of the command, from user input to execution and updating the Model.
As seen from the diagram above, the entire command consists of 4 main steps:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/findtags-activitydiagram.png" alt="findtags activitydiagram" width="200">
</div>
</div>
<div class="paragraph">
<p>1) The parameters are parsed and deciphered.<br>
2) Using the deciphered information from step 1, the Predicate and Command are constructed.<br>
3) Command is executed.<br>
4) Predicate is called and the Model is updated.</p>
</div>
<div class="paragraph">
<p>More detailed explanations and elaborations are given in the subsections below.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-of-parser"><a class="link" href="#implementation-of-parser">Implementation of Parser</a></h4>
<div class="paragraph">
<p>he parser associated with this command is FindPersonsWithTagsCommandParser, under seedu.address.logic.parser. Due to this parser’s long name, it will be referred to as the “command parser” or simply “parser” within this section to aid clarity.</p>
</div>
<div class="paragraph">
<p>When this command is invoked by the user, this command parser will be constructed by AddressbookParser, receiving the user’s input as a String parameter. The command parser deciphers the input, and eventually returns a FindPersonsWithTagsCommand for execution.</p>
</div>
<div class="paragraph">
<p>The command parser first checks if the arguments are valid. If the arguments are empty, a ParseException will be thrown for invalid arguments. If the arguments are valid (non-empty), they are split into individual keywords and stored in a String array tagKeywords.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/StringToTagKeywords.png" alt="StringToTagKeywords" width="800">
</div>
</div>
<div class="paragraph">
<p>As the diagram above shows, the keywords are split by the spaces in between each word, and each of these words are stored in a String array tagKeywords.</p>
</div>
<div class="paragraph">
<p>The array of keywords is then passed into the parser’s private method, getImprovedList(), to retrieve a more comprehensive list of tags in addition to the original list of keywords.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The details of <strong>getImprovedList</strong> is not crucially important to the functionality of the parser, and is thus omitted here, but included in the addendum in Section 3.3.6.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After obtaining the improved list, the parser constructs the command Predicate (details in Section 3.3.4), and the Command itself (details in the Section 3.3.5). Then it returns the Command to AddressbookParser and then the LogicManager for execution.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-of-predicate"><a class="link" href="#implementation-of-predicate">Implementation of Predicate</a></h4>
<div class="paragraph">
<p>The Predicate associated with this functionality is called PersonContainsTagsPredicate, found in seedu.address.model.person. This Predicate is constructed with the keywords generated in the command parser (details in the above section). After this Predicate is constructed, it is used in the constructor of a FindPersonsWithTagsCommand and becomes that command’s attribute.</p>
</div>
<div class="paragraph">
<p>When the command is executed, this Predicate will be called for every contact in the address book to determine if a contact should be filtered or not based on the user’s inputs.</p>
</div>
<div class="paragraph">
<p>To do so, the test method of this Predicate is used, which returns a Boolean value: true if this contact should be returned, and false otherwise.</p>
</div>
<div class="paragraph">
<p>Within this test method, there are 3 steps which occur:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/findtags-pathdiagram.png" alt="findtags pathdiagram" width="800">
</div>
</div>
<div class="paragraph">
<p>The diagram above gives a brief overview of the three steps executed in the Predicate.</p>
</div>
<div class="paragraph">
<p>Firstly, all of the person’s tags, if any, are appended to a String allTagNames. For example, if a contact has tags "friends" and "colleagues", the resulting String is "friends colleagues".</p>
</div>
<div class="paragraph">
<p>Secondly, the list of keywords, now an attribute of the Predicate, is split into 2 lists, keywordsToInclude and keywordsToExclude. Note that it is possible for either list to be empty.</p>
</div>
<div class="paragraph">
<p>Last but not least, the comparison is made between allTagNames and the 2 lists generated in the second part, to return the appropriate Boolean value. Below is the code snippet used in the comparison. Note that this is not the only way to implement this comparison.</p>
</div>
<div class="paragraph">
<p><strong>Code Snippet:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//For scenario 2</span>
<span class="keyword">if</span> (onlyKeywordsToExcludeAreSpecified) {
            <span class="keyword">return</span> !(keywordsToExclude.stream()
                    .anyMatch((keyword -&gt; StringUtil.containsWordIgnoreCase(allTagNames, keyword))));
}


<span class="comment">//For scenarios 1 and 3</span>
<span class="keyword">return</span> keywordsToInclude.stream()
    .anyMatch(keyword -&gt; StringUtil.containsWordIgnoreCase(allTagNames, keyword)) &amp;&amp;
    !(keywordsToExclude.stream()
    .anyMatch((keyword -&gt; StringUtil.containsWordIgnoreCase(allTagNames, keyword))));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="implementation-of-command"><a class="link" href="#implementation-of-command">Implementation of Command</a></h4>
<div class="paragraph">
<p>The command executed in this feature is FindPersonsWithTagsCommand, found in seedu.address.logic.commands.</p>
</div>
<div class="paragraph">
<p>After the command parser returns the command to AddressbookParser and then to the LogicManager, assuming that no exceptions are thrown so far, the command is executed, by calling its execute() method.</p>
</div>
<div class="paragraph">
<p>In this execute() method, the current model invokes its updateFilteredPersonList method, with the command Predicate as described above as its parameter.</p>
</div>
<div class="paragraph">
<p>This runs the test method of the Predicate, which determines the appropriate contacts to filter. This causes the model to update accordingly and filters the contacts displayed in the UI.</p>
</div>
<div class="paragraph">
<p>Finally, this command returns a CommandResult, which includes the number of contacts being displayed. This value is displayed on the UI command box for the user’s reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="addendum"><a class="link" href="#addendum">Addendum</a></h4>
<div class="paragraph">
<p><strong>Implementation of getImprovedList</strong><br>
In the command parser (as detailed in Section 3.3.3), there exists a private method getImprovedList(), which takes in the list of keywords entered by the user and attempts to return a more comprehensive one in addition to the original list, to account for grammatical differences in plural and singular forms of the keywords.</p>
</div>
<div class="paragraph">
<p>To give an example, if the keyword is “friend”, the extra keyword generated is “friends” and vice-versa. This works for “exclusion-keywords” (keywords with a dash in front) as well.</p>
</div>
<div class="paragraph">
<p>What is of note is that this method is merely a crude, quality-of-life improvement for the user. It simply generates the keywords by appending the letter ‘s’ to keywords which do not end with ‘s’, and removes ‘s’ from words that do end with the letter ‘s’.</p>
</div>
<div class="paragraph">
<p>As a result, it does not account for words where singular and plural forms differ by more than just a single letter ‘s’, such as “family” and “families”.</p>
</div>
<div class="paragraph">
<p>It is therefore recommended that future developers improve this method, perhaps by implementing a proper dictionary or library for this method, after weighing the costs and benefits. Alternatively, this idea could be further improved or refined on with a Lookup Table to save file storage space.</p>
</div>
<div class="paragraph">
<p>Nevertheless, this improvement is meant to increase user enjoyment and convenience. The bonus of organising and spelling tags in an organised manner is still on the user. To that end,  if the case arises that, based on user feedback, this improvement does more harm than good, it is recommended that this feature be removed or made optional. Although, this is not something that the current developers foresee will occur based on how people in general spell their tags.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations"><a class="link" href="#design-considerations">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect:</strong> Improving list of keywords.<br>
<strong>Alternative 1 (current choice):</strong> Add 's' to letters that do not end with 's', and vice-versa.<br>
<strong>Pros:</strong> Easy to implement and read.<br>
<strong>Cons:</strong> Does not account for all words in English, may have non-English words.<br>
<strong>Alternative 2:</strong> Import appropriate library for getting singular/plural words.<br>
<strong>Pros:</strong> More likely to account for all words.<br>
<strong>Cons:</strong> May impact performance.<br>
<strong>Alternative 3:</strong> Implement a Look-up Table.<br>
<strong>Pros:</strong> Can account for more words than alternative 1, and less impactful on performance and storage than alternative 2.<br>
<strong>Cons:</strong> Might be difficult to implement and may not be as comprehensive as alternative 2.<br></p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect</strong>: Comparision of tag names and keywords in predicate.<br>
<strong>Alternative 1 (current choice): </strong>Append names to an empty String for comparision with keywords.<br>
<strong>Pros:</strong> Easy to implement and change.<br>
<strong>Cons:</strong> Requires use of lambda, which may be more difficult to understand for beginners.<br>
<strong>Alternative 2:</strong> Compare tag against tag by encapsulating all keywords into Tags.<br>
<strong>Pros:</strong> Can use the equals specified in Tag, and/or comparator instead of lambda for better readability.<br>
<strong>Cons:</strong> More difficult to implement, and may create many tags that are never used because the keywords and expanded to improve user convenience (singular vs plural tag names).<br></p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="enhancement-added-list-tags"><a class="link" href="#enhancement-added-list-tags">Enhancement Added: List Tags</a></h3>
<div class="sect3">
<h4 id="external-behavior-2"><a class="link" href="#external-behavior-2">External behavior</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="list-tags-code-listtags-code-br"><a class="link" href="#list-tags-code-listtags-code-br">List tags : <code>listtags</code><br></a></h3>
<div class="paragraph">
<p><code>since v1.3</code></p>
</div>
<div class="paragraph">
<p>Lists all existing tags in the App<br></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Listing all tags is designed to help you choose which tags to specify when using <code>findtags</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="the-command-2"><a class="link" href="#the-command-2">The Command</a></h4>
<div class="paragraph">
<p>Format: <code>listtags</code></p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="justification-2"><a class="link" href="#justification-2">Justification</a></h4>
<div class="paragraph">
<p>The main intention of this enhancement is to supplement the find by tags function as described above.
For users with large numbers of tags, it may be difficult to remember what tags are saved in the application.
This enhancement allows users to easily refer to the tags that they have saved in the application, enhancing ease of use and quality of life.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-2"><a class="link" href="#implementation-2">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="implementation-of-list-tags"><a class="link" href="#implementation-of-list-tags">Implementation of List Tags</a></h3>
<div class="paragraph">
<p>The application allows users to see the list of all tags that are currently attached to contacts in the application. The command word is <code>listtags</code>, and
the shortcut alternative is <code>lt</code>. The follow subsections explain how the program is supposed to function given the command, and how it is implemented.</p>
</div>
<div class="sect3">
<h4 id="user-inputs-and-expected-actions-results-2"><a class="link" href="#user-inputs-and-expected-actions-results-2">User Inputs and Expected Actions/Results</a></h4>
<div class="paragraph">
<p>In general, when this command is used, there are only 2 scenarios that will occur.</p>
</div>
<div class="paragraph">
<p><strong>Scenario 1</strong><br>
There is at least 1 tag attached to at least 1 contact.</p>
</div>
<div class="paragraph">
<p>In this scenario, the application will show these tags in the result box.</p>
</div>
<div class="paragraph">
<p>Below is the format of the results:<br>
You have the following tags: [tag1] [tag2] [tag3] &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><strong>Scenario 2</strong><br>
There are no tags attached to any contacts in the application. This could happen if there are:<br>
1. No contacts in the application.<br>
2. No tags attached to any contact.</p>
</div>
<div class="paragraph">
<p>In this scenario, the application will show to user the following message:<br>
"You do not have any tags!"</p>
</div>
</div>
<div class="sect3">
<h4 id="brief-overview-of-the-command"><a class="link" href="#brief-overview-of-the-command">Brief Overview of the Command</a></h4>
<div class="paragraph">
<p>A brief overview of the steps taken by the application in producing the appropriate results is as given:<br>
1. Creates a list of tags by iterating through every Contact in the application and adding their tags to the list.<br>
2. Check if this list of tags is empty or not, that is, whether it is scenario 1 or scenario 2.<br>
2a. If it is scenario 2, that is, there are no tags to output, the command merely returns the failure message.<br>
3. If the list is not empty, it will output the success message along with the list of tags in the appropriate format. The details of this step is given
in the next subsection.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-of-success-scenario"><a class="link" href="#implementation-of-success-scenario">Implementation of Success Scenario</a></h4>
<div class="paragraph">
<p>The steps taken are:<br>
1. Converts the list of Tags to a list of String containing the names of each Tag.<br>
2. Sorts the list in alphabetical order.<br>
3. Using a StringBuilder, appends the names to each other with the appropriate formatting.<br>
4. Output the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations-2"><a class="link" href="#design-considerations-2">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect:</strong> Order of Tags displayed<br>
<strong>Alternative 1 (current choice):</strong> Display in alphabetical order.<br>
<strong>Pros:</strong> More readable and more easily understood.<br>
<strong>Cons:</strong> May not be the most meaningful.<br></p>
</div>
<div class="paragraph">
<p><strong>Alternative 2:</strong> Display based on how many of each tag there are, for example in ascending order.<br>
<strong>Pros:</strong> Might be more meaningful for certain users and cases.<br>
<strong>Cons:</strong> Much more difficult to implement, and may appear more confusing to users, as alphabetical order is generally more easily understood.<br></p>
</div>
<div class="paragraph">
<p><strong>Alternative 3:</strong> Allow option to display both in alphabetical order or in ascending order.<br>
<strong>Pros:</strong> Best of both worlds, allowing user to choose the most meaningful.<br>
<strong>Cons:</strong> Adding on to the already numerous commands may not be the most meaningful, especially when the main
function of this enhancement is to complement the find tags feature.</p>
</div>
<hr>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="other-contributions"><a class="link" href="#other-contributions">Other contributions</a></h3>
<div class="ulist">
<ul>
<li>
<p>Allow contacts to support a Facebook URL field (Pull Request <a href="https://github.com/CS2103AUG2017-T11-B4/main/pull/46">46</a>).</p>
</li>
<li>
<p>Select Command now opens the Facebook URL of the Contact in the Browser
(Pull Request <a href="https://github.com/CS2103AUG2017-T11-B4/main/pull/95">#95</a>).</p>
</li>
<li>
<p>Updated the GUI color scheme (Pull request <a href="https://github.com/CS2103AUG2017-T11-B4/main/pull/93">#93</a>).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-11-09 19:57:22 +08:00
</div>
</div>
</body>
</html>
